# [Introduction to OS](https://pages.cs.wisc.edu/~remzi/OSTEP/Korean/02-intro.pdf)

## Index

- [서론](#서론)
- [1. CPU 가상화](#1-cpu-가상화)
- [2. 메모리 가상화](#2-메모리-가상화)
- [3. 병행성](#3-병행성)
- [4. 영속성](#4-영속성)
- [5. 설계 목표](#5-설계-목표)
- [6. 역사](#6-역사)

## 서론
프로그램은 매우 단순한 일을 반복한다.
그 일은 명령어를 실행하는 것인데 프로세서는 명령어를 초당 수백만 번(현재는 수십억 번) **반입(fetch)** 하고, **해석(decode)** 한 뒤, **실행(excute)** 하는 것이다.
명령어 작업을 완료한 후, 프로세서는 다음 명령어로, 또 그 다음 명령어로 프로그램이 완전히 종료될 때까지 실행을 계속한다.

> 현대의 프로세서는 프로그램을 빠르게 실행시키기 위해 명령어 동시 실행, 명령어 순서 바꾸기 등 다양한 행동을 한다.
> 그러나 우리는 대부분의 프로그램이 가정하고 있는 한 번에 하나의 명령어만 실행되고 순차적으로 실행되는 단순한 모델에만 관심을 갖는다.

위의 과정은 **Von Neumann** 컴퓨팅 모델의 기초이다.
이번 챕터는 시스템 사용을 **쉽게하기 위해서(easy to use)** 프로그램 실행 시 다양한 일들이 발생한다는 것을 배우게 될 것이다.

프로그램을 쉽게 실행하고(동시에 실행하기도 하고), 프로그램 간의 메모리 공유를 가능케 하고, 장치와 상호작용을 가능케하고, 다양하고 흥미로운 일을 할 수 있게 하는 소프트웨어를 **운영체제(operating)**이라고 한다.

> 시스템을 사용하기 편리하면서 정확하고 올바르게 동작시킬 책임이 있기 때문에 운영체제란 이름이 붙었다.

운영체제는 앞선 일들을 수행하기 위해서 **가상화(virtualization)** 라고 불리는 기법을 사용한다.
운영체제는 프로세서, 메모리, 디스크와 같은 **물리적(physical)** 인 자원을 이용하여 1) 보편적이고(general), 강력하고, 사용이 편리한 가상 형태의 자원을 생성한다.
그렇기에 운영체제를 때로는 **가상 머신(virtual machine)** 이라고 부른다.

사용자 프로그램의 프로그램 실행, 메모리 할당, 파일 접근과 같은 가상 머신과 관련된 기능들을 운영체제에게 요청할 수 있도록, 운영체제는 사용자에게 API르 제공하며 이를 **시스템 콜** 이라고 한다..
운영체제는 응용 프로그램이 사용 가능한 수백 개의 **시스템 콜** 을 제공하며 이러한 기능 때문에 운영체제가 표준 라이브러리(standard library)를 제공한다고 말하기도 한다.

> ### 시스템 콜(system call)
> 운영체제의 커널이 제공하는 서비스에 대해, 응용 프로그램의 요청에 따라 커널에 접근하기 위한 인터페이스

또한 가상화는 많은 프로그램들이 CPU를 공유하여, 동시에 실행될 수 있게 한다.
프로그램들이 각자 명령어와 데이터에 접근할 수 있게 하며 디스크 등의 장치를 공유할 수도 있게 한다.
이러한 이유로 운영체제를 **자원 관리자(resource manager)** 라고 불리기도 한다.
CPU, 메모리, 디스크는 시스템의 **자원** 이다.
이러한 자원을 효율적이고 공정하게 관리하는 것이 운영체제의 역할이다.

## 1. CPU 가상화
> ### 핵심 질문: 자원을 어떻게 가상화시키는가
> 가상화를 하는 이유는 시스템 사용을 편리하게 만들기 때문이다.
> 그렇다면 운영체제는 자원을 어떻게 가상화시키는가?
> 어떻게 효율적으로 구현하는가?
> 가상화를 위해 하드웨어는 어떤 지원을 주어야 하는가?
>
> 이를 이번 챕터에서 제시할 것이다.

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>
#include <assert.h>
#include "common.h"

int	main(int argc, char *argv[])
{
	if (argc != 2)
	{
		fprintf(stderr, "usage: cpu <string>\n");
		exit(1);
	}
	char	*str = argv[1];
	while (1)
	{
		Spin(1);
		printf("%s\n", str);
	}
	return (0);
}
```

위 코드는 우리의 첫번째 코드이다.
이 프로그램은 **Spin()** 을 호출하는 일을 한다.
Spin()은 1초 동안 실행된 후 리턴되고 그 후, 사용자가 명령어 라인으로 전달한 문자열을 출력한다.
이러한 일을 무한히 반복한다.

이 코드를 cpu.c라는 이름으로 저장하고 단일 프로세서(CPU와 혼용할 것임) 시스템에서 컴파일하고 실행시킨다고 가정하자.
그렇다면 아래와 같은 출력을 볼 수 있을 것이다.

```shell
prompt> gcc -o cpu cpu.c -Wall
prompt> ./cpu "A"
A
A
A
A
^C
>prompt
```

시스템은 실행 후 1초가 지나면 사용자가 전달한 입력 문자열(이 경우엔 'A')을 출력한다.
그리고 "Control-c"(UNIX 계열 시스템에서 전위 프로그램을 종료시키는 키)를 이용해 종료될 때까지 이를 계속 반복한다.

이번에는 같은 작업에 대한 여러 인스턴스를 동시에 실행시켜 보자.
아래의 출력은 처음보단 조금 복잡한 결과를 나타낸다.

```shell
prompt> ./cpu A & ; ./cpu B & ; ./cpu C & ; ./cpu D &
[1] 7353
[2] 7354
[3] 7355
[4] 7356
A
B
D
C
A
B
D
C
A
C
B
D
...
```

이는 프로세서가 하나밖에 없음에도 프로그램 4개를 모두 실행되는 것처럼 보인다.

> 여기서 &를 사용하여 동시에 4개의 프로그램을 실행시키는 방법에 주목해야 한다.
> 이렇게 하면 [tcsh 쉘](https://ko.wikipedia.org/wiki/Tcsh) 상에서 작업을 백그라운드로 실행시킬 수 있다.
> 이는 사용자가 다음 명령어를 곧바로 실행시킬 수 있다는 것을 의미한다.
>
> 또한 ;은 tcsh에서 동시에 여러 프로그램을 실행시킬 수 있게 한다.
> 다른 쉘을 사용하고 있다면 약간 다르게 실행시켜야 한다.

이러한 동작을 어떻게 가능하게 하는가?

하드웨어의 도움을 받아 운영체제가 시스템에 수많은 가상 CPU가 존재하는 듯한 **환상(*illusion)** 을 만들어 낸 것이다.
이렇게 하나의 CPU 또는 소규모 CPU 집합을 무한 개의 CPU가 존재하는 것처럼 변환하여 동시에 수많은 프로그램을 실행시키는 것을 **CPU 가상화(virtualization the CPU)** 라 한다.

다수의 프로그램을 동시에 실행시킬 수 있는 기능은 새로운 종류의 문제를 발생시킬 수 있다.
예를 들어, 특정 순간에 두 개의 프로그램이 실행되도록 요청되었다면 누가 먼저 실행되어야 하는가?
이것은 운영체제의 정책(policy)에 달렸다.
운영체제의 여러 부분에서 이러한 유형의 문제에 답하기 위한 정책들이 사용된다.
운영체제가 구현한 동시에 다수의 프로그램을 실행시키는 **기본적인 기법(mechanism)** 에 대해 다룰 것이다.
즉, **자원 관리자** 로서의 운영체제 역할을 다룬다.

## 2. 메모리 가상화
현재 컴퓨터가 사용하고 있는 **물리 메모리(physical memory)** 모델은 바이트의 배열로 매우 단순하다.
그렇기에 메모리를 읽거나 쓰기 위해서는 데이터에 **주소(address)** 를 명시해야 한다.

메모리는 프로그램이 실행되는 동안 항상 접근이 가능하다.
프로그램은 실행 중에 자신의 모든 자료 구조를 메모리에 유지하고 load, store나 그 외의 메모리 접근을 위한 명령어를 통하여 자료 구조에 접근한다.
이러한 명령어 역시 메모리에 존재하기에 명령어를 fetch할 때마다 메모리에 접근된다.

```c
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include "common.h"

int	main(int argc, char *argv[])
{
	int	*p = malloc(sizeof(int)); // a1
	assert(p != NULL);
	printf("(%d) memory address of p: %08x\n", getpid(), (unsigned) p); // a2
	*p = 0; // a3
	while (1)
	{
		Spin(1);
		*p = *p + 1;
		printf("(%d) p: %d\n", getpid(), *p); // a4
	}
	return (0);
}
```

위의 코드는 **malloc()** 을 호출하여 메모리를 할당하는 프로그램이다.
위 코드의 출력은 다음과 같다.

```shell
prompt> ./mem
(2134) memory address of p: 00200000
(2134) p: 1
(2134) p: 2
(2134) p: 3
(2134) p: 4
(2134) p: 5
∧C
```

프로그램과 함께 결과를 살펴보자면 다음과 같다.
1. a1행에서 메모리를 할당받는다.
2. a2행에서 할당받은 메모리의 주소를 출력한다.
3. a3행에서 새로 할당받은 메모리의 첫 슬롯에 숫자 0을 넣는다.
4. a4행에서 루프에 진입하여 1초 대기 후, 변수 p가 가리키는 주소에 저장되어 있는 값을 1 증가시킨다.

출력할 때마다 실행 중인 프로그램의 프로세스 식별자(PID)도 함께 출력한다.

만약 프로그램을 여러 번 실행시킨다면 다음과 같은 결과가 나온다.

```shell
prompt> ./mem &; ./mem &
[1] 24113
[2] 24114
(24113) memory address of p: 00200000
(24114) memory address of p: 00200000
(24113) p: 1
(24114) p: 1
(24114) p: 2
(24113) p: 2
(24113) p: 3
(24114) p: 3
(24113) p: 4
(24114) p: 4
. . .
```

프로그램들은 같은 주소 메모리를 할당받지만(00200000), 각각이 독립적인 00200000 번지의 값을 갱신한다.
각 프로그램은 물리 메모리를 다른 프로그램과 공유하는 것이 아니라 각자 자신의 메모리를 가지고 있는 것처럼 보인다.

> 이 예제 코드가 동작하기 위해서는 주소 공간 난수화 기능을 꺼야 한다.
> 앞으로 나오겠지만 난수화는 특정 유형의 보안 취약점을 방어하는데 좋은 방어법이다.

이렇게 보이는 이유가 바로 운영체제가 **메모리 가상화(virtualizing memory)** 를 하기 때문이다.
각 프로세스는 자신만의 **가상 주소 공간(virtual address space, 혹은 주소 공간(address space)))** 을 갖는다. 운영체제는 이 가상 주소 공간을 컴퓨터의 물리 메모리로 mapping한다. 그렇기에 하나의 프로그램이 수행하는 각종 메모리 연산은 다른 프로그램의 주소 공간에 영향을 주지 않는다. 실행 중인 프로그램의 입장에서는 자신만의 물리 메모리를 갖는 셈이다.

이것이 실제로 일어나는 과정은 첫 주제인 **가상화(virtualization)** 에 포함되어 있다.

## 3. 병행성
가상화 외에도 이 책은 **병행성(concurrency)** 이다.
프로그램이 한 번에 많은 일을 하려 할 때(즉 동시에), 발생하는 그리고 반드시 해결해야 하는 문제들을 가리킬 때 병행성이란 단어를 사용한다.

병행성 문제는 여러 곳에서 발생한는데 우선적으론 운영체제 자체에서 발생한다.
앞선 가상화에 관한 예에서 알 수 있듯이 운영체제는 하나의 프로세스 실행, 다음 프로세스, 그 다음 프로세스 등의 순서로 여러 프로세스를 실행시켜 한 번에 많은 일을 한다. 그리고 이 동작은 심각하고 흥미로운 문제를 야기한다.

또한 병행성 문제는 운영체제의 문제만은 아니다.
**멀티 쓰레드** 프로그램도 동일한 문제를 드러낸다.
밑의 코드를 통해 **멀티 쓰레드** 프로그램의 예를 확인해 보자.

```c
#include <stdio.h>
#include <stdlib.h>
#include "common.h"

volatile int	counter = 0;
int	loops;

void	*worker(void *arg)
{
	int	i;
	for (i = 0; i < loops; i++)
	{
		counter++;
	}
	return NULL;
}

int	main(int argc, char *argv[])
{
	if (argc != 2)
	{
		fprintf(stderr, "usage: threads <value>\n");
		exit(1);
	}
	loops = atoi(argv[1]);
	pthread_t	p1, p2;
	printf("Initial value: %d\n", counter);

	Pthread_create(&p1, NULL, worker, NULL);
	Pthread_create(&p2, NULL, worker, NULL);
	Pthread_join(p1, NULL);
	Pthread_join(p2, NULL);
	printf("Final value: %d\n", counter);
	return (0);
}
```

나중에 병행성 부분에서 더 자세히 배우겠지만 기본 아이디어는 메인 프로그램에서 **Pthread_create()** 를 사용하여 두 개의 쓰레드를 생성한다.
이때 쓰레드를 동일한 메모리 공간에서 함께 실행 중인 여러 개의 함수라고도 생각할 수 있다.
이 예제 코드에선 각 쓰레드는 **worker()** 라는 루틴을 실행한다.
**worker()** 루틴은 loops번 만큼 루프를 반복하면서 카운터 값을 증가시킨다.

> Pthread_create()로 호출했지만 실제로는 소문자로 시작하는 pthread_create()가 호출되어야 한다.
> 대문자로 시작하는 버전은 pthread_create()를 호출하고 반환 코드가 호출 성공을 나타냈는지 검사하도록 이 책에서 만든 wrapper 함수이다.

loops 값은 각 쓰레드가 카운터를 증가시키는 횟수이다.
loops 변수를 1000으로 설정하여 프로그램을 실행시켰을 때 결과는 아래와 같다.

```shell
prompt> gcc −o thread thread.c −Wall −pthread
prompt> ./thread 1000
Initial value : 0
Final value : 2000
```

각 쓰레드가 1000번씩 counter 값을 증가시켰기 때문에 counter의 최종 값은 2000번이 된다.
이를 토대로 loops 값이 N이면 최종 출력은 2N이 될 것이라고 예상할 수 있다.
그러나 그리 간단한 문제는 아니다.
아래는 입력 값을 100,000으로 주었을 때 결과이다.

```shell
prompt> ./thread 100000
Initial value : 0
Final value : 143012
prompt> ./thread 100000
Initial value : 0
Final value : 137298
```

예상은 최종 값이 200,000을 예상했지만 실제는 143,012번이 나왔다.
또한 다시 실행시켰을 때는 137,298번이 나오는 것을 확인할 수 있다.
물론 모든 결과과 다르게 나오진 않고 200,000번이 나올 떄도 있다.
왜 이런 일이 생기는 것인가?

이러한 결과의 원인은 명령어가 한 번에 하나씩만 실행된다는 것과 관련이 있다.
앞 프로그램의 핵심 부분인 counter를 증가시키는 부분은 세 개의 명령어로 이루어진다.

1. counter 값을 메모리에서 레지스터로 탑재하는 명령어
2. 레지스터를 1 증가시키는 명령어
3. 레지스터의 값을 다시 메모리에 저장하는 명령어

이 세 개의 명령어가 **원자적(atomically)** 으로(한 번에 3개 모두) 실행되지 않기 때문에 이상한 일이 발생할 수 있다.
이것이 책의 후반부에서 자세하게 논의할 **병행성(concurrency)** 문제이다.

> ### 핵심 질문: 올바르게 동작하는 병행 프로그램은 어떻게 작성해야 하는가?
> - 같은 메모리 공간에 다수의 쓰레드가 동시에 실행한다고 할 때, 올바르게 동작하는 프로그램은 어떻게 작성할 수 있는가?
> - 운영체제로부터 어떤 기본 기법들을 제공받아야 하는가?
> - 하드웨어는 어떤 기능을 제공해야 하는가?
> - 병행성 문제를 해결하기 위하여 기본 기법들과 하드웨어 기능을 어떻게 이용할 수 있는가?

## 4. 영속성
DRAM과 같은 장치는 데이터를 **휘발성(volatile)** 방식으로 저장하기 때문에 메모리의 데이터는 쉽게 손실될 수 있다. 전원 공급이 끊어지거나 시스템이 갑자기 고장나면(crash) 메모리의 모든 데이터가 사라진다. 그렇기에 데이터를 **영속적** 으로 저장할 수 있는 하드웨어와 소프트웨어가 필요하다. 

하드웨어는 **입력/출력(input/output)** 혹은 **I/O** 장치 형태로 제공된다. 요즘은 **solid-state drives(SSDs)** 가 많이 사용되고 있지만 장기간 보존할 정보를 저장하는 장치로는 일반적으로 **하드 드라이브(hard drive)** 가 사용된다.

이러한 디스크를 관리하는 운영체제 소프트웨어를 **파일 시스템(file system)** 이라고 부른다. 파일 시스템은 사용자가 생성한 **파일(file)** 을 시스템의 디스크에 안전하고 효율적인 방식으로 저장할 책임이 있다.

CPU나 메모리 가상화와는 달리 운영체제는 프로그램 별로 가상 디스크를 따로 생성하지 않는다. 오히려 사용자들이 종종 파일 정보를 공유하기 원한다고 가정한다. 예를 들어, C 프로그램을 작성할 때, 우선 에디터를 사용하여 C파일을 생성하고 편집한다. 편집이 끝나면 소스 코드를 컴파일한다. 컴파일이 완료되면 새로 생성된 실행 파일을 실행할 수 있다. 이런 식의 실행 파일 공유를 원한다고 운영체제는 가정한다.

> ### 핵심 질문: 데이터를 영속적으로 저장하는 방법은 무엇인가
> 파일 시스템은 데이터를 영속적으로 관리하는 운영체제의 일부분이다.
> - 올바르게 일하기 위해서는 어떤 기법이 필요할까?
> - 이러한 작업의 성능을 높이기 위해서 어떤 기법과 정책이 필요한가?
> - 하드웨어와 소프트웨어가 실패하더라도 올바르게 동작하려면 어떻게 해야 하는가?

> 저자는 vi를 말고 반드시 Emacs 편집기를 사용하라고 이야기한다. 이 이유는 무엇인가?

영속성을 더 살펴보기 위해 입출력을 수행하는 코드를 살펴보자.

```c
#include <stdio.h>
#include <unistd.h>
#include <assert.h>
#include <fcntl.h>
#include <sys/types.h>

int main(int argc, char *argv[])
{
	int fd = open("/tmp/file", O_WRONLY | O_CREAT | O_TRUNC, S_IRWXU);
	assert(fd > -1);
	int rc = write(fd, "hello world\n", 13);
	assert(rc == 13);
	close(fd);
	return (0);
}
```

위 코드에서 프로그램은 운영체제를 세 번 호출한다.

1. **open()** 콜은 파일을 생성하고 연다.
2. **write()** 콜은 파일에 데이터를 쓴다.
3. **close()** 콜은 단순히 파일을 닫는데, 프로그램이 더 이상 해당 파일을 사용하지 않는다는 것을 나타낸다.

이들 시스템 콜은 운영체제에서 **파일 시스템(file system)** 이라 불리는 부분으로 전달된다. 파일 시스템은 전달된 요청을 처리하고 경우에 따라 사용자에게 에러 코드를 반환한다.

데이터를 디스크에 쓰기 위해서 운영체제가 실제로 하는 일은 그리 간단하지 않다. 파일 시스템은 많은 작업들을 해야 한다. 먼저 새 데이터가 디스크 어디에 저장될지 결정하고, 파일 시스템이 관리하는 다양한 자료 구조를 통하여 데이터의 상태를 추적해야 한다. 이런 작업을 하기 위해서 저장 장치로부터, 기존 자료 구조를 읽거나 갱신해야 한다. 이를 위해서는 저수준 장치 인터페이스와 그 시맨틱에 대한 깊은 이해가 필요하다. 운영체제는 시스템 콜이라는 표준화된 방법으로 장치들에 접근할 수 있게 한다. 이러한 관점에선 운영체제는 **표준 라이브러리(standard library)** 처럼 보이기도 한다.

읽고 쓰는 것도 충분히 복잡하지만 장치를 접근하는 방법과 파일 시스템이 데이터를 영속적으로 관리하는 방법은 이보다 더욱 복잡하다. 대부분의 파일 시스템은 성능 향상을 위해서 쓰기요청을 지연시켜서 취합된 요청을 한 번에 처리한다. 그리고 쓰기 중에 시스템의 갑작스런 고장에 대비해서 많은 파일 시스템들이 **[저널링(journaling)](https://ko.wikipedia.org/wiki/%EC%A0%80%EB%84%90%EB%A7%81_%ED%8C%8C%EC%9D%BC_%EC%8B%9C%EC%8A%A4%ED%85%9C)** 이나 **[쓰기 시 복사(Copy-On-Write)](https://code-lab1.tistory.com/58)** 와 같은 복잡한 쓰기 기법을 사용한다. 이런 기법들은 쓰기 순서를 적절히 조정하여 고장이 발생하더라도 정상적인 상태로 복구될 수 있게 한다. 

장치와 입출력에 관한 전반적인 내용과 디스크, RAID와 파일 시스템에 대해 영속성 파트에서 아주 상세히 다룰 예정이다.

## 5. 설계 목표

앞선 설명을 봐서 알 수 있듯이 운영체제는 CPU, 메모리, 디스크와 같은 물리 자원을 **가상화(virtualize)** 한다. 그리고 운영체제는 **병행성** 과 관련된 복잡한 문제를 처리한다. 또한 파일을 **영속적** 으로 저장하여 아주 오랜 시간 동안 안전한 상태에 있게 한다. 이런 시스템을 만들기 위해 몇가지 목표가 필요하다.

가장 기본적인 목표는 시스템을 편리하고 사용하기 쉽게 만드는데 필요한 **개념(abstraction)** 들을 정의하는 것이다. 컴퓨터 과학에서 추상화는 모든 일에 근간이다. 추상화를 통해 큰 프로그램을 이해하기 쉬운 작은 부분들로 나누어 구현할 수 있다. 저수준 언어를 몰라도 고수준 언어로 큰 프로그램을 작동시킬 수 있으며 논리 게이트를 고려하지 않고도 어셈블리 코드를 작성할 수 있고 트랜지스터에 대한 지식없이도 게이트를 이용하여 프로세서를 만들 수 있다. 추상화는 너무 근본이기에 잊어버리기 쉽지만 절대 잊어서 안 되는 가장 기본적인 목표이다.

운영체제의 설계와 구현에 중요한 목표는 **성능(오버헤드 최소화, minimize the overhead)** 이다. 가상화와 사용하기 쉬운 시스템을 만드는 것은 의미가 있지만 반드시 해야하는 것은 아니다. 그러나 가상화 및 다른 운영체제 기능을 과도한 오버헤드 없이 제공해야 한다. 오버헤드(어떤 처리를 하기 위해 들어가는 간접적인 처리 시간, 메모리 등)는 시간(더 많은 명령어)과 공간(메모리 또는 디스크)의 형태로 나타난다. 시간과 공간을 최소화하는 해결책을 찾도록 노력할 것이며 절충안도 공부할 것이다.

또 다른 목표는 응용 프로그램 간의 **보호** , 그리고 운영체제와 응용 프로그램 간의 **보호** 이다. 다수 프로그램들이 동시에 실행되기 때문에, 운영체제는 한 프로그램의 악의적이나 의도치 않은 행위가 다른 프로그램에게 피해를 주지 않음을 보장해야 한다. 당연히 응용 프로그램 역시 운영체제에게 해를 끼치지 않아야 한다. 보호는 운영체제의 원칙 중 하나인 **고립(isolation)** 원칙의 핵심이다. 프로세스를 다른 프로세스로부터 고립시키는 일은 보호의 핵심이고 운영체제가 해야 하는 많은 일의 근간이 된다.

운영체제가 계속 실행되는 것도 중요한 목표이다. 운영체제가 실패하면 그 위에서 실행되는 모든 응용 프로그램도 실패하기 때문이다. 이러한 종속성 때문에 운영체제는 높은 수준의 **신뢰성(reliability)** 을 제공해야 한다. 운영체제가 복잡해질수록, 신뢰성 있는 운영체제를 구현하는 일은 매우 어려워진다. 운영체제 분야의 많은 연구들이 바로 이 문제에 초점을 맞추고 있다.

그 외에도 **에너지 효율성(energy-efficiency)** 은 환경을 위해, 악의적인 응용 프로그램 **보안(security, 사실상 보호의 확장)** 은 현재와 같은 네트워크 환경에서 특히 중요하다. **이동성(mobility)** 은 운영체제가 작은 장치에서 사용될수록 중요해지고 있다. 시스템의 목적에 따라 운영체제는 다른 목표를 지향하고 구현도 달라진다.

## 6. 역사

### 초창기 운영체제: 단순 라이브러리

초창기 운영체제는 기본적으로 자주 사용되는 함수들을 모아 놓은 라이브러리에 불과했다. 예를 들어 프로그래머들이 각자 저수준 입출력 처리 코드를 작성하는 것이 아니라 운영체제가 그런 API를 제공했다. 

이러한 옛날 메인프레임 시스템에서는 컴퓨터를 조작하는 사람이 프로그램을 한 번에 하나씩 실행하였다. 현대 운영체제가 하는 일 중 하나인 작업 순서를 정하는 것 역시 컴퓨터 관리자 담당했다. 

작업들이 준비되면 컴퓨터 관리자가 일괄적으로 처리한다. 이러한 방식의 컴퓨팅을 **일괄 처리(batch)** 라고 부른다. 

### 라이브러리를 넘어서: 보호

그러다 운영체제가 단순 라이브러리를 넘어서 컴퓨터 관리 면에서 더 중심적인 역할을 하게 된다. 이러한 방식이 등장하게 된 원인 중 하나는 운영체제가 실행하는 코드가 특별하다는 인식이었다. 운영체제 코드는 장치를 제어할 수 있기에 일반 응용 프로그램 코드와는 다르게 취급되어야 했다. 모든 프로그램이 장치를 제어할 수 있다면 수많은 문제가 발생하기에 라이브러리 형태로 **파일 시스템** 구현하는 것은 의미가 없었다.

이를 해결하기 위해 Atlas 컴퓨팅 시스템에 의해 **시스템 콜** 이라는 아이디어가 나왔다. 운영체제를 라이브러리가 아니라 특별한 하드웨어 명령어와 하드웨어 상태를 결합하여 운영체제로 전환하기 위해서 시스템 콜은 정해진 규칙에 따라 제어 가능한 과정을 거치도록 만들었다.

시스템 콜과 프로시저 호출의 결정적 차이는 시스템 콜은 제어를 운영체제에게 넘길 때, **하드웨어 특권 수준(hardware privilege level)** 을 상향 조정한다는 것이다. 사용자 응용 프로그램은 사용자 **사용자 모드(user mode)** 에서 실행한다. 사용자 모드에서는 응용 프로그램이 할 수 있는 일을 하드웨어적으로 제한한다. 디스크 입출력, 물리 메모리 페이지 접근 또는 네트워크 패킷 송신 등의 작업을 막는 것이다. 이에 비해 시스템 콜은 보통 **trap** 이라고 불리는 특별한 하드웨어 명령어를 이용하여 호출된다. 시스템 콜 시작 시, 하드웨어는 미리 지정된(그리고 운영체제가 미리 구현해놓은) **트랩 핸들러(trap handler)** 함수에게 제어권을 넘기고 특권 수준을 **커널 모드(kernel mode)** 로 격상시킨다. 커널 모드에선 운영체제가 시스템의 하드웨어를 자유롭게 접근할 수 있으며 입출력 또는 메모리 할당 등의 작업을 할 수 있다. 이러한 서비스가 끝나면 **return-from-trap** 이란 특수 명령어를 사용하여 사용자 모드로 돌아가며 제어권을 사용자에게 넘긴다.

### 멀티프로그래밍 시대

이후, **미니컴퓨터(minicompu-ter)** 에 등장으로 큰 기관에 하나씩 있던 컴퓨터가 소그룹마다 하나씩 생기게 되었다. 이는 개발자 활동을 더 활발히 만들었고 더 유능한 인원들이 개발을 할 수 있는 환경을 조성한다.

이에 따라 컴퓨터 자원을 효율적으로 사용하기 위해 **멀티프로그래밍(multiprogramming)** 기법이 대중적으로 사용되었다. 한 번에 하나의 프로그램만 실행시키지 않고 여러 작업을 메모리에 탑재한 채, 작업들을 빠르게 번갈아 가며 실행하여 CPU 사용률을 향상시킨 것이다. 특히 입출력 장치가 느리기 때문에 전환(switching) 능력이 중요했다. 입출력 요청이 실행되는 동안 CPU가 대기하는 것은 비효율적이기 때문이다.

이러한 멀티프로그래밍 지원의 필요성과 인터럽트를 통한 입출력 작업 처리 등은 운영체제 발전에 여러 혁신을 가져왔다. 다른 프로그램 메모리에 접근하지 못하게 하는 **메모리 보호(memory protection)** , 멀티프로그래밍에서 발생하는 **병행성(concurrency)** 묹제 등이 대표적이다. 운영체제는 인터럽트가 발생하더라도 운영체제가 올바르게 동작하는 것이 보장되어야 했다. 물론 이는 어려운 작업이고 이는 후반부에서 살펴볼 예정이다.

특별히 이 시대에 UNIX가 등장하며 많은 발전을 이루었다. 이는 PDF를 참고할 것.

### 현대

소그룹마다 컴퓨터를 가지는 미니컴퓨터 시대를 지나 더 싸고 대중적인 **개인용 컴퓨터(personal computer)** , 즉 **PC** 가 등장했다. 이는 개인이 하나씩 가질 수 있는 가격이었기에 컴퓨팅을 주도하는 기기가 되었다.

물론 이 과정에서 미니컴퓨터의 운영체제가 가지고 있던 메모리 보호, 스케줄링 등을 고려하지 않아서 퇴보했다는 평을 듣기도 했지만 결국 문제를 해결하기 위해 이러한 기술들을 다시 채용하면서 데스크톱 컴퓨터용 운영체제가 등장하기 시작했다.

## 참고문헌
- [위키백과, 시스템 호출](https://ko.wikipedia.org/wiki/%EC%8B%9C%EC%8A%A4%ED%85%9C_%ED%98%B8%EC%B6%9C)
- [위키백과, tcsh](https://ko.wikipedia.org/wiki/Tcsh)
- [위키백과, 저널링 파일 시스템](https://ko.wikipedia.org/wiki/%EC%A0%80%EB%84%90%EB%A7%81_%ED%8C%8C%EC%9D%BC_%EC%8B%9C%EC%8A%A4%ED%85%9C)
- [코드 연구소, [운영체제] Copy On Write(COW)란? | Copy On Write 예시](https://code-lab1.tistory.com/58)
- [위키백과, 오버헤드](https://ko.wikipedia.org/wiki/%EC%98%A4%EB%B2%84%ED%97%A4%EB%93%9C)
- 
