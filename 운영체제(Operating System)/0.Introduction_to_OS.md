# [Introduction to OS](https://pages.cs.wisc.edu/~remzi/OSTEP/Korean/02-intro.pdf)

## Index

- [서론](#서론)
- [1. CPU 가상화](#1-cpu-가상화)
- [2. 메모리 가상화](#2-메모리-가상화)
- 

## 서론
프로그램은 매우 단순한 일을 반복한다.
그 일은 명령어를 실행하는 것인데 프로세서는 명령어를 초당 수백만 번(현재는 수십억 번) **반입(fetch)** 하고, **해석(decode)** 한 뒤, **실행(excute)** 하는 것이다.
명령어 작업을 완료한 후, 프로세서는 다음 명령어로, 또 그 다음 명령어로 프로그램이 완전히 종료될 때까지 실행을 계속한다.

> 현대의 프로세서는 프로그램을 빠르게 실행시키기 위해 명령어 동시 실행, 명령어 순서 바꾸기 등 다양한 행동을 한다.
> 그러나 우리는 대부분의 프로그램이 가정하고 있는 한 번에 하나의 명령어만 실행되고 순차적으로 실행되는 단순한 모델에만 관심을 갖는다.

위의 과정은 **Von Neumann** 컴퓨팅 모델의 기초이다.
이번 챕터는 시스템 사용을 **쉽게하기 위해서(easy to use)** 프로그램 실행 시 다양한 일들이 발생한다는 것을 배우게 될 것이다.

프로그램을 쉽게 실행하고(동시에 실행하기도 하고), 프로그램 간의 메모리 공유를 가능케 하고, 장치와 상호작용을 가능케하고, 다양하고 흥미로운 일을 할 수 있게 하는 소프트웨어를 **운영체제(operating)**이라고 한다.

> 시스템을 사용하기 편리하면서 정확하고 올바르게 동작시킬 책임이 있기 때문에 운영체제란 이름이 붙었다.

운영체제는 앞선 일들을 수행하기 위해서 **가상화(virtualization)** 라고 불리는 기법을 사용한다.
운영체제는 프로세서, 메모리, 디스크와 같은 **물리적(physical)** 인 자원을 이용하여 1) 보편적이고(general), 강력하고, 사용이 편리한 가상 형태의 자원을 생성한다.
그렇기에 운영체제를 때로는 **가상 머신(virtual machine)** 이라고 부른다.

사용자 프로그램의 프로그램 실행, 메모리 할당, 파일 접근과 같은 가상 머신과 관련된 기능들을 운영체제에게 요청할 수 있도록, 운영체제는 사용자에게 API르 제공하며 이를 **시스템 콜** 이라고 한다..
운영체제는 응용 프로그램이 사용 가능한 수백 개의 **시스템 콜** 을 제공하며 이러한 기능 때문에 운영체제가 표준 라이브러리(standard library)를 제공한다고 말하기도 한다.

> ### 시스템 콜(system call)
> 운영체제의 커널이 제공하는 서비스에 대해, 응용 프로그램의 요청에 따라 커널에 접근하기 위한 인터페이스

또한 가상화는 많은 프로그램들이 CPU를 공유하여, 동시에 실행될 수 있게 한다.
프로그램들이 각자 명령어와 데이터에 접근할 수 있게 하며 디스크 등의 장치를 공유할 수도 있게 한다.
이러한 이유로 운영체제를 **자원 관리자(resource manager)** 라고 불리기도 한다.
CPU, 메모리, 디스크는 시스템의 **자원** 이다.
이러한 자원을 효율적이고 공정하게 관리하는 것이 운영체제의 역할이다.

## 1. CPU 가상화
> ### 자원을 어떻게 가상화시키는가
> 가상화를 하는 이유는 시스템 사용을 편리하게 만들기 때문이다.
> 그렇다면 운영체제는 자원을 어떻게 가상화시키는가?
> 어떻게 효율적으로 구현하는가?
> 가상화를 위해 하드웨어는 어떤 지원을 주어야 하는가?
>
> 이를 이번 챕터에서 제시할 것이다.

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>
#include <assert.h>
#include "common.h"

int	main(int argc, char *argv[])
{
	if (argc != 2)
	{
		fprintf(stderr, "usage: cpu <string>\n");
		exit(1);
	}
	char	*str = argv[1];
	while (1)
	{
		Spin(1);
		printf("%s\n", str);
	}
	return (0);
}
```

위 코드는 우리의 첫번째 코드이다.
이 프로그램은 **Spin()** 을 호출하는 일을 한다.
Spin()은 1초 동안 실행된 후 리턴되고 그 후, 사용자가 명령어 라인으로 전달한 문자열을 출력한다.
이러한 일을 무한히 반복한다.

이 코드를 cpu.c라는 이름으로 저장하고 단일 프로세서(CPU와 혼용할 것임) 시스템에서 컴파일하고 실행시킨다고 가정하자.
그렇다면 아래와 같은 출력을 볼 수 있을 것이다.

```shell
prompt> gcc -o cpu cpu.c -Wall
prompt> ./cpu "A"
A
A
A
A
^C
>prompt
```

시스템은 실행 후 1초가 지나면 사용자가 전달한 입력 문자열(이 경우엔 'A')을 출력한다.
그리고 "Control-c"(UNIX 계열 시스템에서 전위 프로그램을 종료시키는 키)를 이용해 종료될 때까지 이를 계속 반복한다.

이번에는 같은 작업에 대한 여러 인스턴스를 동시에 실행시켜 보자.
아래의 출력은 처음보단 조금 복잡한 결과를 나타낸다.

```shell
prompt> ./cpu A & ; ./cpu B & ; ./cpu C & ; ./cpu D &
[1] 7353
[2] 7354
[3] 7355
[4] 7356
A
B
D
C
A
B
D
C
A
C
B
D
...
```

이는 프로세서가 하나밖에 없음에도 프로그램 4개를 모두 실행되는 것처럼 보인다.

> 여기서 &를 사용하여 동시에 4개의 프로그램을 실행시키는 방법에 주목해야 한다.
> 이렇게 하면 [tcsh 쉘](https://ko.wikipedia.org/wiki/Tcsh) 상에서 작업을 백그라운드로 실행시킬 수 있다.
> 이는 사용자가 다음 명령어를 곧바로 실행시킬 수 있다는 것을 의미한다.
>
> 또한 ;은 tcsh에서 동시에 여러 프로그램을 실행시킬 수 있게 한다.
> 다른 쉘을 사용하고 있다면 약간 다르게 실행시켜야 한다.

이러한 동작을 어떻게 가능하게 하는가?

하드웨어의 도움을 받아 운영체제가 시스템에 수많은 가상 CPU가 존재하는 듯한 **환상(*illusion)** 을 만들어 낸 것이다.
이렇게 하나의 CPU 또는 소규모 CPU 집합을 무한 개의 CPU가 존재하는 것처럼 변환하여 동시에 수많은 프로그램을 실행시키는 것을 **CPU 가상화(virtualization the CPU)** 라 한다.

다수의 프로그램을 동시에 실행시킬 수 있는 기능은 새로운 종류의 문제를 발생시킬 수 있다.
예를 들어, 특정 순간에 두 개의 프로그램이 실행되도록 요청되었다면 누가 먼저 실행되어야 하는가?
이것은 운영체제의 정책(policy)에 달렸다.
운영체제의 여러 부분에서 이러한 유형의 문제에 답하기 위한 정책들이 사용된다.
운영체제가 구현한 동시에 다수의 프로그램을 실행시키는 **기본적인 기법(mechanism)** 에 대해 다룰 것이다.
즉, **자원 관리자** 로서의 운영체제 역할을 다룬다.

## 2. 메모리 가상화

## 참고문헌
- [위키백과, 시스템 호출](https://ko.wikipedia.org/wiki/%EC%8B%9C%EC%8A%A4%ED%85%9C_%ED%98%B8%EC%B6%9C)
- [위키백과, tcsh](https://ko.wikipedia.org/wiki/Tcsh)
