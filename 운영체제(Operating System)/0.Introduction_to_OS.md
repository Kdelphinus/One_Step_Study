# [Introduction to OS](https://pages.cs.wisc.edu/~remzi/OSTEP/Korean/02-intro.pdf)

## Index

- [서론](#서론)
- [1. CPU 가상화](#1-cpu-가상화)
- [2. 메모리 가상화](#2-메모리-가상화)
- 

## 서론
프로그램은 매우 단순한 일을 반복한다.
그 일은 명령어를 실행하는 것인데 프로세서는 명령어를 초당 수백만 번(현재는 수십억 번) **반입(fetch)** 하고, **해석(decode)** 한 뒤, **실행(excute)** 하는 것이다.
명령어 작업을 완료한 후, 프로세서는 다음 명령어로, 또 그 다음 명령어로 프로그램이 완전히 종료될 때까지 실행을 계속한다.

> 현대의 프로세서는 프로그램을 빠르게 실행시키기 위해 명령어 동시 실행, 명령어 순서 바꾸기 등 다양한 행동을 한다.
> 그러나 우리는 대부분의 프로그램이 가정하고 있는 한 번에 하나의 명령어만 실행되고 순차적으로 실행되는 단순한 모델에만 관심을 갖는다.

위의 과정은 **Von Neumann** 컴퓨팅 모델의 기초이다.
이번 챕터는 시스템 사용을 **쉽게하기 위해서(easy to use)** 프로그램 실행 시 다양한 일들이 발생한다는 것을 배우게 될 것이다.

프로그램을 쉽게 실행하고(동시에 실행하기도 하고), 프로그램 간의 메모리 공유를 가능케 하고, 장치와 상호작용을 가능케하고, 다양하고 흥미로운 일을 할 수 있게 하는 소프트웨어를 **운영체제(operating)**이라고 한다.

> 시스템을 사용하기 편리하면서 정확하고 올바르게 동작시킬 책임이 있기 때문에 운영체제란 이름이 붙었다.

운영체제는 앞선 일들을 수행하기 위해서 **가상화(virtualization)** 라고 불리는 기법을 사용한다.
운영체제는 프로세서, 메모리, 디스크와 같은 **물리적(physical)** 인 자원을 이용하여 1) 보편적이고(general), 강력하고, 사용이 편리한 가상 형태의 자원을 생성한다.
그렇기에 운영체제를 때로는 **가상 머신(virtual machine)** 이라고 부른다.

사용자 프로그램의 프로그램 실행, 메모리 할당, 파일 접근과 같은 가상 머신과 관련된 기능들을 운영체제에게 요청할 수 있도록, 운영체제는 사용자에게 API르 제공하며 이를 **시스템 콜** 이라고 한다..
운영체제는 응용 프로그램이 사용 가능한 수백 개의 **시스템 콜** 을 제공하며 이러한 기능 때문에 운영체제가 표준 라이브러리(standard library)를 제공한다고 말하기도 한다.

> ### 시스템 콜(system call)
> 운영체제의 커널이 제공하는 서비스에 대해, 응용 프로그램의 요청에 따라 커널에 접근하기 위한 인터페이스

또한 가상화는 많은 프로그램들이 CPU를 공유하여, 동시에 실행될 수 있게 한다.
프로그램들이 각자 명령어와 데이터에 접근할 수 있게 하며 디스크 등의 장치를 공유할 수도 있게 한다.
이러한 이유로 운영체제를 **자원 관리자(resource manager)** 라고 불리기도 한다.
CPU, 메모리, 디스크는 시스템의 **자원** 이다.
이러한 자원을 효율적이고 공정하게 관리하는 것이 운영체제의 역할이다.

## 1. CPU 가상화
> ### 핵심 질문: 자원을 어떻게 가상화시키는가
> 가상화를 하는 이유는 시스템 사용을 편리하게 만들기 때문이다.
> 그렇다면 운영체제는 자원을 어떻게 가상화시키는가?
> 어떻게 효율적으로 구현하는가?
> 가상화를 위해 하드웨어는 어떤 지원을 주어야 하는가?
>
> 이를 이번 챕터에서 제시할 것이다.

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>
#include <assert.h>
#include "common.h"

int	main(int argc, char *argv[])
{
	if (argc != 2)
	{
		fprintf(stderr, "usage: cpu <string>\n");
		exit(1);
	}
	char	*str = argv[1];
	while (1)
	{
		Spin(1);
		printf("%s\n", str);
	}
	return (0);
}
```

위 코드는 우리의 첫번째 코드이다.
이 프로그램은 **Spin()** 을 호출하는 일을 한다.
Spin()은 1초 동안 실행된 후 리턴되고 그 후, 사용자가 명령어 라인으로 전달한 문자열을 출력한다.
이러한 일을 무한히 반복한다.

이 코드를 cpu.c라는 이름으로 저장하고 단일 프로세서(CPU와 혼용할 것임) 시스템에서 컴파일하고 실행시킨다고 가정하자.
그렇다면 아래와 같은 출력을 볼 수 있을 것이다.

```shell
prompt> gcc -o cpu cpu.c -Wall
prompt> ./cpu "A"
A
A
A
A
^C
>prompt
```

시스템은 실행 후 1초가 지나면 사용자가 전달한 입력 문자열(이 경우엔 'A')을 출력한다.
그리고 "Control-c"(UNIX 계열 시스템에서 전위 프로그램을 종료시키는 키)를 이용해 종료될 때까지 이를 계속 반복한다.

이번에는 같은 작업에 대한 여러 인스턴스를 동시에 실행시켜 보자.
아래의 출력은 처음보단 조금 복잡한 결과를 나타낸다.

```shell
prompt> ./cpu A & ; ./cpu B & ; ./cpu C & ; ./cpu D &
[1] 7353
[2] 7354
[3] 7355
[4] 7356
A
B
D
C
A
B
D
C
A
C
B
D
...
```

이는 프로세서가 하나밖에 없음에도 프로그램 4개를 모두 실행되는 것처럼 보인다.

> 여기서 &를 사용하여 동시에 4개의 프로그램을 실행시키는 방법에 주목해야 한다.
> 이렇게 하면 [tcsh 쉘](https://ko.wikipedia.org/wiki/Tcsh) 상에서 작업을 백그라운드로 실행시킬 수 있다.
> 이는 사용자가 다음 명령어를 곧바로 실행시킬 수 있다는 것을 의미한다.
>
> 또한 ;은 tcsh에서 동시에 여러 프로그램을 실행시킬 수 있게 한다.
> 다른 쉘을 사용하고 있다면 약간 다르게 실행시켜야 한다.

이러한 동작을 어떻게 가능하게 하는가?

하드웨어의 도움을 받아 운영체제가 시스템에 수많은 가상 CPU가 존재하는 듯한 **환상(*illusion)** 을 만들어 낸 것이다.
이렇게 하나의 CPU 또는 소규모 CPU 집합을 무한 개의 CPU가 존재하는 것처럼 변환하여 동시에 수많은 프로그램을 실행시키는 것을 **CPU 가상화(virtualization the CPU)** 라 한다.

다수의 프로그램을 동시에 실행시킬 수 있는 기능은 새로운 종류의 문제를 발생시킬 수 있다.
예를 들어, 특정 순간에 두 개의 프로그램이 실행되도록 요청되었다면 누가 먼저 실행되어야 하는가?
이것은 운영체제의 정책(policy)에 달렸다.
운영체제의 여러 부분에서 이러한 유형의 문제에 답하기 위한 정책들이 사용된다.
운영체제가 구현한 동시에 다수의 프로그램을 실행시키는 **기본적인 기법(mechanism)** 에 대해 다룰 것이다.
즉, **자원 관리자** 로서의 운영체제 역할을 다룬다.

## 2. 메모리 가상화
현재 컴퓨터가 사용하고 있는 **물리 메모리(physical memory)** 모델은 바이트의 배열로 매우 단순하다.
그렇기에 메모리를 읽거나 쓰기 위해서는 데이터에 **주소(address)** 를 명시해야 한다.

메모리는 프로그램이 실행되는 동안 항상 접근이 가능하다.
프로그램은 실행 중에 자신의 모든 자료 구조를 메모리에 유지하고 load, store나 그 외의 메모리 접근을 위한 명령어를 통하여 자료 구조에 접근한다.
이러한 명령어 역시 메모리에 존재하기에 명령어를 fetch할 때마다 메모리에 접근된다.

```c
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include "common.h"

int	main(int argc, char *argv[])
{
	int	*p = malloc(sizeof(int)); // a1
	assert(p != NULL);
	printf("(%d) memory address of p: %08x\n", getpid(), (unsigned) p); // a2
	*p = 0; // a3
	while (1)
	{
		Spin(1);
		*p = *p + 1;
		printf("(%d) p: %d\n", getpid(), *p); // a4
	}
	return (0);
}
```

위의 코드는 **malloc()** 을 호출하여 메모리를 할당하는 프로그램이다.
위 코드의 출력은 다음과 같다.

```shell
prompt> ./mem
(2134) memory address of p: 00200000
(2134) p: 1
(2134) p: 2
(2134) p: 3
(2134) p: 4
(2134) p: 5
∧C
```

프로그램과 함께 결과를 살펴보자면 다음과 같다.
1. a1행에서 메모리를 할당받는다.
2. a2행에서 할당받은 메모리의 주소를 출력한다.
3. a3행에서 새로 할당받은 메모리의 첫 슬롯에 숫자 0을 넣는다.
4. a4행에서 루프에 진입하여 1초 대기 후, 변수 p가 가리키는 주소에 저장되어 있는 값을 1 증가시킨다.

출력할 때마다 실행 중인 프로그램의 프로세스 식별자(PID)도 함께 출력한다.

만약 프로그램을 여러 번 실행시킨다면 다음과 같은 결과가 나온다.

```shell
prompt> ./mem &; ./mem &
[1] 24113
[2] 24114
(24113) memory address of p: 00200000
(24114) memory address of p: 00200000
(24113) p: 1
(24114) p: 1
(24114) p: 2
(24113) p: 2
(24113) p: 3
(24114) p: 3
(24113) p: 4
(24114) p: 4
. . .
```

프로그램들은 같은 주소 메모리를 할당받지만(00200000), 각각이 독립적인 00200000 번지의 값을 갱신한다.
각 프로그램은 물리 메모리를 다른 프로그램과 공유하는 것이 아니라 각자 자신의 메모리를 가지고 있는 것처럼 보인다.

> 이 예제 코드가 동작하기 위해서는 주소 공간 난수화 기능을 꺼야 한다.
> 앞으로 나오겠지만 난수화는 특정 유형의 보안 취약점을 방어하는데 좋은 방어법이다.

이렇게 보이는 이유가 바로 운영체제가 **메모리 가상화(virtualizing memory)** 를 하기 때문이다.
각 프로세스는 자신만의 **가상 주소 공간(virtual address space, 혹은 주소 공간(address space)))** 을 갖는다. 운영체제는 이 가상 주소 공간을 컴퓨터의 물리 메모리로 mapping한다. 그렇기에 하나의 프로그램이 수행하는 각종 메모리 연산은 다른 프로그램의 주소 공간에 영향을 주지 않는다. 실행 중인 프로그램의 입장에서는 자신만의 물리 메모리를 갖는 셈이다.

이것이 실제로 일어나는 과정은 첫 주제인 **가상화(virtualization)** 에 포함되어 있다.

## 3. 병행성
가상화 외에도 이 책은 **병행성(concurrency)** 이다.
프로그램이 한 번에 많은 일을 하려 할 때(즉 동시에), 발생하는 그리고 반드시 해결해야 하는 문제들을 가리킬 때 병행성이란 단어를 사용한다.

병행성 문제는 여러 곳에서 발생한는데 우선적으론 운영체제 자체에서 발생한다.
앞선 가상화에 관한 예에서 알 수 있듯이 운영체제는 하나의 프로세스 실행, 다음 프로세스, 그 다음 프로세스 등의 순서로 여러 프로세스를 실행시켜 한 번에 많은 일을 한다. 그리고 이 동작은 심각하고 흥미로운 문제를 야기한다.

또한 병행성 문제는 운영체제의 문제만은 아니다.
**멀티 쓰레드** 프로그램도 동일한 문제를 드러낸다.
밑의 코드를 통해 **멀티 쓰레드** 프로그램의 예를 확인해 보자.

```c
#include <stdio.h>
#include <stdlib.h>
#include "common.h"

volatile int	counter = 0;
int	loops;

void	*worker(void *arg)
{
	int	i;
	for (i = 0; i < loops; i++)
	{
		counter++;
	}
	return NULL;
}

int	main(int argc, char *argv[])
{
	if (argc != 2)
	{
		fprintf(stderr, "usage: threads <value>\n");
		exit(1);
	}
	loops = atoi(argv[1]);
	pthread_t	p1, p2;
	printf("Initial value: %d\n", counter);

	Pthread_create(&p1, NULL, worker, NULL);
	Pthread_create(&p2, NULL, worker, NULL);
	Pthread_join(p1, NULL);
	Pthread_join(p2, NULL);
	printf("Final value: %d\n", counter);
	return (0);
}
```

나중에 병행성 부분에서 더 자세히 배우겠지만 기본 아이디어는 메인 프로그램에서 **Pthread_create()** 를 사용하여 두 개의 쓰레드를 생성한다.
이때 쓰레드를 동일한 메모리 공간에서 함께 실행 중인 여러 개의 함수라고도 생각할 수 있다.
이 예제 코드에선 각 쓰레드는 **worker()** 라는 루틴을 실행한다.
**worker()** 루틴은 loops번 만큼 루프를 반복하면서 카운터 값을 증가시킨다.

> Pthread_create()로 호출했지만 실제로는 소문자로 시작하는 pthread_create()가 호출되어야 한다.
> 대문자로 시작하는 버전은 pthread_create()를 호출하고 반환 코드가 호출 성공을 나타냈는지 검사하도록 이 책에서 만든 wrapper 함수이다.

loops 값은 각 쓰레드가 카운터를 증가시키는 횟수이다.
loops 변수를 1000으로 설정하여 프로그램을 실행시켰을 때 결과는 아래와 같다.

```shell
prompt> gcc −o thread thread.c −Wall −pthread
prompt> ./thread 1000
Initial value : 0
Final value : 2000
```

각 쓰레드가 1000번씩 counter 값을 증가시켰기 때문에 counter의 최종 값은 2000번이 된다.
이를 토대로 loops 값이 N이면 최종 출력은 2N이 될 것이라고 예상할 수 있다.
그러나 그리 간단한 문제는 아니다.
아래는 입력 값을 100,000으로 주었을 때 결과이다.

```shell
prompt> ./thread 100000
Initial value : 0
Final value : 143012
prompt> ./thread 100000
Initial value : 0
Final value : 137298
```

예상은 최종 값이 200,000을 예상했지만 실제는 143,012번이 나왔다.
또한 다시 실행시켰을 때는 137,298번이 나오는 것을 확인할 수 있다.
물론 모든 결과과 다르게 나오진 않고 200,000번이 나올 떄도 있다.
왜 이런 일이 생기는 것인가?

이러한 결과의 원인은 명령어가 한 번에 하나씩만 실행된다는 것과 관련이 있다.
앞 프로그램의 핵심 부분인 counter를 증가시키는 부분은 세 개의 명령어로 이루어진다.

1. counter 값을 메모리에서 레지스터로 탑재하는 명령어
2. 레지스터를 1 증가시키는 명령어
3. 레지스터의 값을 다시 메모리에 저장하는 명령어

이 세 개의 명령어가 **원자적(atomically)** 으로(한 번에 3개 모두) 실행되지 않기 때문에 이상한 일이 발생할 수 있다.
이것이 책의 후반부에서 자세하게 논의할 **병행성(concurrency)** 문제이다.

> ### 핵심 질문: 올바르게 동작하는 병행 프로그램은 어떻게 작성해야 하는가?
> - 같은 메모리 공간에 다수의 쓰레드가 동시에 실행한다고 할 때, 올바르게 동작하는 프로그램은 어떻게 작성할 수 있는가?
> - 운영체제로부터 어떤 기본 기법들을 제공받아야 하는가?
> - 하드웨어는 어떤 기능을 제공해야 하는가?
> - 병행성 문제를 해결하기 위하여 기본 기법들과 하드웨어 기능을 어떻게 이용할 수 있는가?


## 참고문헌
- [위키백과, 시스템 호출](https://ko.wikipedia.org/wiki/%EC%8B%9C%EC%8A%A4%ED%85%9C_%ED%98%B8%EC%B6%9C)
- [위키백과, tcsh](https://ko.wikipedia.org/wiki/Tcsh)
