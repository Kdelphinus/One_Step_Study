## 기본 개념

```c
lock_t mutex; // 전역 변수로 선언된 lock
...
lock(&mutex);
balance = balance + 1;
unlock(&mutex);
```

- 락은 하나의 변수이기에 사용하기 위해 먼저 선언(mutex와 같이)해야 한다.
- 락은 락의 상태를 나타낸다.
	- 사용 가능(available): unlocked, free로도 이야기함
	- 사용 중(acquired): 임계 영역에서 정확히 하나의 쓰레드가 락을 획득한 상태
- 락 사용자는 이 정보를 알 수 없다.
- 쓰레드가 lock을 호출했을 때, 사용 가능하다면 쓰레드는 임계 영역에 진입한다.
- 만약 하나의 쓰레드가 락을 획득했는데 다른 쓰레드가 락을 호출하면 기존의 쓰레드가 락을 반환할 때까지 lock() 함수는 리턴하지 않는다.
- lock 사용자가 unlock()을 호출하면 락은 이제 다시 사용 가능 상태로 돌아온다.
- 이때, 대기 중인 쓰레드가 있다면 락을 획득하고 임계 영역으로 들어간다.
- 락을 통해 프로세스들의 혼란스러운 실행 순서에 어느 정도 질서를 부여할 수 있다.

## pthread 락

- POSIX 라이브러리는 쓰레드 간의 **상호 배제(mutual exclusion)** 기능을 제공하기에 이 안에 락을 **mutex** 라고 부른다. 
- 상호 배제는 말 그대로 하나의 쓰레드가 락을 얻었을 때, 다른 쓰레드들이 락을 얻지 못하도록 제한하는 데에서 이름을 따왔다.
- 락의 개수들을 통해 여러 전략도 사용할 수 있다.
	- 하나의 락이 임의의 임계 영역을 진입할 때마다 사용되는 것(**거친(coarse-grained) 락 사용 전략**)
	- 서로 다른 데이터와 자료 구조를 보호하기 위해 여러 락을 사용하여 한 번에 여러 쓰레드가 서로 다른 락으로 보호된 코드 내에서 각자가 진입이 가능하도록 하는 것(**세밀한(fine-grained) 락 사용 전략**)

## 락 구현

- 하드웨어와 운영체제의 도움이 필요하다.
- 정교한 락 라이브러리를 제작하는데, 사용되는 하드웨어 명렁어들과 운영체제가 관여하는 부분을 이어서 살핀다.

## 락의 평가

- 먼저 락을 만들기 전에 어떤 목적으로 구현하고, 어떤 방법으로 평가할지를 정해야 한다.
- 평가 기준
	- 상호 배제를 제대로 지원하는가
	- 쓰레드들에게 공정한 락 획득의 기회가 주어지는가
	- 성능은 준수한가
		- 단일 쓰레드일 때, 락을 획득하고 해제하는 과정에서 발생하는 부하는 얼마나 되는가
		- 여러 쓰레드가 단일 CPU 상에서 락을 획득하려 할 때 성능은 어떻게 되는가
		- 멀티 CPU 상황에서 락 경쟁 시의 성능은 어떻게 되는가

## 인터럽트 제어

- 초기 단일 프로세스 시스템에서는 상호 배제를 위해 임계 영역 내에서 인터럽트를 비활성화하는 방법을 사용했었다.
- 임계 영역에 진입하기 전에 특별한 하드웨어 명령어를 사용하여 인터럽트를 막았다.
- 이는 단순한 장점이 있다.
- 허나 많은 단점이 있다.
	- 쓰레드가 인터럽트를 활성/비활성화하는 **특권(privileged)** 연산을 실행할 수 있도록 허가해야 한다.
		- 그러면서 이 특권을 다른 목적으로 사용하지 않음을 신뢰할 수 있어야 한다.
		- 그러나 운영체제가 잘 알지 못하는 프로그램을 신뢰하는 것은 좋지 않은 경우
		- 예를 들어 탐욕적 기법을 사용한 프로그램이 lock을 계속 호출하여 lock을 무한정 얻어 무한 반복문에 들어갈 수 있다.
		- 이는 운영체제가 응용 프로그램을 너무 많이 신뢰해야 한다.
	- 멀티프로세스에서 적용할 수 없다.
		- 특정 프로세서에서 인터럽트 비활성화는 다른 프로ㅔ써에서 실행 중인 프로그램에게 전혀 영향을 주지 않는다.
	- 장시간동안 인터럽트를 중지시키는 것은 중요한 인터럽트의 시점을 놓칠 수 있다.
		- CPU가 저장 장치에서 읽기 요청을 마친 사실을 모르고 지나갔을 경우, 읽기 결과를 기다리는 프로세스를 영원히 깨우지 않을 수 있다.
	- 비효율적이다.
		- 인터럽트를 비활성화 시키는 코드는 최신 CPU들에서 느리게 실행되는 경향이 있다.

## Test-And-Set (Atomic Exchange)

- 멀티프로세서에선 인터럽트를 중지시키는 것이 의미가 업식에 락 지원을 위한 하드웨어를 설계하기 시작
- 이렇게 설계된 기법 중 가장 기본적인 기법이 **Test-And-Set** 명령어 혹은 **원자적 교체(atomic exchange)** 라고 불리는 기법이다. 
	- 임계 영역에 진입하는 첫 쓰레드가 lock()을 호출하여 플래그 값이 1인지 검사
	- 아니면 플래그를 1로 설정하고 이 쓰레드가 락을 보유하고 있다고 표시
	- 임계 영역에서 나오면 unlock()을 호출하여 플래그 값을 초기화하여 락을 더 이상 보유하고 있지 않다고 표시
- 이미 임계 영역에 쓰레드가 있는데 다른 쓰레드가 lock()을 호출하면 그 쓰레드는 while 문으로 **spin-wait** 을 하며 처음 쓰레드가 unlock() 을 호출하여 플래그를 초기화하기를 기다린다.
- 그러나 이 방법도 두 가지 문제점이 있다.
	- 정확성
		- 병행 프로그래밍에 익숙해지면 쉽게 알아볼 수 있다.
		- 적시에 인터럽트가 발생하면 두 쓰레드에 대해 플래그 1을 줄 수 있다.
	- 성능
		- 락을 얻기 위해 대기하는 부분에서 성능 문제가 생긴다.
		- spin-wait이라는 방법은 플래그의 값을 무한히 검사하는데, 이는 다른 쓰레드가 락을 해제할 때까지 시간을 낭비한다.
		- 단일 프로세스에서 매우 손해가 크며 이 경우, 락을 소유한 쓰레드조차 문맥 교환 없이는 실행이 불가능해진다.

## 진짜 돌아가는 스핀 락의 구현

- 앞선 예제는 하드웨어의 지원이 필요하다.
- 그리고 이를 지원해주는 시스템들도 많이 존재한다.
- 간단하게 Test-And-Set을 코드로 구현하면 다음과 같다.

```c
int TestAndSet(int *old_ptr, int new)
{
	int old = *old_ptr; // old_ptr의 이전 값을 가져옴
	*old_ptr = new;     // old_ptr에 'new' 값을 지정
	return old;         // old의 값을 반환함
}
```

- 이 코드의 핵심은 각 동작들이 원자적으로 수행된다는 것이다.
- 이름이 test and set인 이유는 검사(test)하는 동시에 메모리에 새로운 값을 설정(set)하기 때문이다. 그리고 이 동작을 원자적 연산으로 만듦으로써 오직 하나의 쓰레드만 락을 획득할 수 있도록 만들었다.
- 이것만으로 간단한 **스핀 락(spin lock)** 을 만들 수 있다.
- 락을 획득할 때까지, CPU 사이클을 소모하면서 회전한다. 그렇기에 스핀 락이라고 부른다.
- 단일 프로세서에선 이 방식을 제대로 사용하기 위해서 **선점형 스케줄러(preemptive scheduler)** 를 사용한다.
	- while문을 회전하며 대기하는 쓰레드가 CPU를 영원히 독점하는 것을 막기 위해서

## 스핀 락 평가

- 락에서 가장 중요한 측면은 **상호 배제의 정확성** 이다.
	- 상호 배제가 가능하다면 스핀 락은 임의의 시간에 단 하나의 쓰레드만이 임계 영역에 진입할 수 있도록 한다.
- 대기 중인 쓰레드들에 있어서 스핀 락이 얼마나 공정한지도 중요하다.
	- 이에 대해 스핀 락은 어떠한 공정성도 보장해주지 않는다.
	- while 문을 회전 중인 쓰레드는 경쟁에 밀려서 계속 그 상태에 남아있다가 기아 상태가 될 수 있다.
- 스핀 락을 사용할 때 지불되는 비용은 어떠한가
	- 단일 프로세서를 사용하며 락을 획득하기 위해 경쟁하는 경우
		- 스핀 락이 갖는 오버헤드가 상당히 클 수 있다.
		- 스케줄러가 락을 획득하려고 시도하는 쓰레드들을 하나씩 깨우며 오버헤드가 상당히 늘어날 수 있다.
		- 쓰레드는 할당받은 기간 동안 CPU 사이클을 낭비하면서 락을 획득하기 위해 대기한다.
	- 멀티 프로세서에 쓰레드가 퍼져있는 경우
		- 단일 프로세서와 다르게 꽤나 효율적으로 동작한다.
		- 쓰레드가 고를 수 있는 CPU의 개수가 많기 떄문이다.

## Compare-And-Swap

```c
int CompareAndSwap(int *ptr, int expected, int new)
{
	int actual = *ptr;
	if (actual == expected)
		*ptr = new;
	return actual;
}
```

- ptr이 가리키고 있는 주소 안에 값이 expected 변수와 일치하는지 검사하는 함수이다.
- 일치한다면 ptr이 가리키고 있는 주소의 값을 새로운 값으로 변경하고, 불일치한다면 아무 것도 하지 않는다.
- 그리고 원래의 메모리 값을 반환하여 CompareAndSwap을 호출한 코드가 락 획득의 성공 여부를 알 수 있도록 한다.
- 이는 락을 얻지 못한 쓰레드가 대기하지 않도록 만들어준다.
- 그렇기에 TestAndSet보다 더 강하다. **대기없는 동기화(wait-free synchronozation)** 를 다룰 때 강력하게 동작한다.
- 만약 단순 스핀 락과 동일하게 사용하면 앞서 분석한 스핀 락과 다를 바 없다.

## Load-Linked 그리고 Store-Conditional

- MIPS란 구조에선 **load-linked** 와 **store-conditional** 명령어를 앞뒤로 사용하여 락이나 기타 병행 연산을 위한 자료 구조를 만들 수 있다.

```c
int LoadLinked(int *ptr)
{
	return *ptr;
}

int StoreConditional(int *ptr, int value)
{
	if (no one has updated *ptr since the LoadLinked to this address)
	{
		*ptr = value;
		return 1; // 성공
	}
	else
		return 0; // 실패
}
```